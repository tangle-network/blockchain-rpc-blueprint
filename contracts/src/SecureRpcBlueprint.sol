// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "tnt-core/BlueprintServiceManagerBase.sol";
import "./precompiles/Services.sol";

/// @dev Minimal IERC20 interface needed for transfers.
interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
}

/// @title SecureRpcBlueprint
/// @author Generated by AI
/// @dev Manages the lifecycle and job interactions for the Secure RPC Gateway Blueprint.
/// Handles ERC20 payments for temporary access jobs.
contract SecureRpcBlueprint is BlueprintServiceManagerBase {
    // --- Job IDs (match Rust implementation) ---
    uint8 constant ALLOW_ACCESS_JOB_ID = 0;
    uint8 constant PAY_FOR_ACCESS_JOB_ID = 1;
    uint8 constant REGISTER_WEBHOOK_JOB_ID = 2;
    

    // --- State Variables --- 
    address public owner;
    address public usdcToken = IERC20(0x0000000000000000000000000000000000000001);
    address public usdtToken = IERC20(0x0000000000000000000000000000000000000002);
    /// @dev 1 USDC = 10^6 smallest token unit,
    /// 10 USDC for 1_000_000 requests
    uint256 public accessPaymentAmount = 10 * 10 ** 6;

    // --- Events --- 

    /// @dev Emitted when a result for the ALLOW_ACCESS_JOB_ID is processed.
    event JobAllowAccessResult(
        uint64 indexed serviceId,
        uint64 indexed jobCallId,
        address indexed operatorAddress,
        bytes inputs,
        bytes outputs
    );

    /// @dev Emitted when a result for the PAY_FOR_ACCESS_JOB_ID is processed.
    /// Note: The beneficiary (who gets access) is the original caller of the job, 
    /// which isn't directly available in onJobResult outputs. Monitor off-chain.
    event JobPayForAccessResult(
        uint64 indexed serviceId,
        uint64 indexed jobCallId,
        address indexed operatorAddress,
        bytes inputs, // SCALE-encoded PayForAccessInput { beneficiary: AccountId32, duration_secs: u64 }
        bytes outputs // Should be empty on success
    );

    /// @dev Emitted when a result for the REGISTER_WEBHOOK_JOB_ID is processed.
    event JobRegisterWebhookResult(
        uint64 indexed serviceId,
        uint64 indexed jobCallId,
        address indexed operatorAddress,
        bytes inputs, // SCALE-encoded RegisterWebhookInput { url: String }
        bytes outputs // Should be empty on success
    );

    // --- Lifecycle Hooks (Inherited & Overridden) ---

    /// @inheritdoc IBlueprintServiceManager
    /// @dev Emits events based on the job ID when results are received.
    function onJobResult(
        uint64 serviceId,
        uint8 job,
        uint64 jobCallId,
        ServiceOperators.OperatorPreferences calldata operator,
        bytes calldata inputs,
        bytes calldata outputs
    )
        external
        payable
        virtual
        override
        onlyFromMaster
    {
        address operatorAddress = operatorAddressFromPublicKey(operator.publicKey);

        if (job == ALLOW_ACCESS_JOB_ID) {
            emit JobAllowAccessResult(serviceId, jobCallId, operatorAddress, inputs, outputs);
        } else if (job == PAY_FOR_ACCESS_JOB_ID) {
            // Note: inputs here are SCALE-encoded { beneficiary: AccountId32, duration_secs: u64 }
            emit JobPayForAccessResult(serviceId, jobCallId, operatorAddress, inputs, outputs);
        } else if (job == REGISTER_WEBHOOK_JOB_ID) {
            emit JobRegisterWebhookResult(serviceId, jobCallId, operatorAddress, inputs, outputs);
        } else {
            revert("SecureRpcBlueprint: Unknown job ID in result");
        }
        // Optional: Add further result verification logic here based on outputs
    }

    // --- Custom User Functions --- 

    /// @notice Allows a user to pay with specified ERC20 token and request temporary access by triggering the PAY_FOR_ACCESS job.
    /// @dev Takes payment and calls the Services precompile to initiate the job.
    /// The user must have approved this contract to spend the required amount of tokens beforehand.
    /// @param _serviceId The ID of the target service instance.
    /// @param _tokenAddress The address of the ERC20 token (USDC or USDT) to pay with.
    function requestTemporaryAccess(
        uint64 _serviceId, 
        address _tokenAddress,
    ) 
        external 
    { 
        require(accessPaymentAmount > 0, "Payment not configured");
        require(
            _tokenAddress == usdcToken || _tokenAddress == usdtToken,
            "Unsupported payment token"
        );

        // Verify allowance BEFORE attempting transferFrom
        uint256 allowed = IERC20(_tokenAddress).allowance(msg.sender, address(this));
        require(allowed >= accessPaymentAmount, "ERC20 allowance insufficient");

        // Take payment
        bool success = IERC20(_tokenAddress).transferFrom(msg.sender, address(this), accessPaymentAmount);
        require(success, "ERC20 transfer failed");

        // Call the Services precompile to dispatch the job
        SERVICES_CONTRACT.callJob(
            _serviceId, 
            PAY_FOR_ACCESS_JOB_ID, 
            _encodedJobArgs
        );
    }

    // --- Helper Functions --- 

    /// @dev Converts a public key to an operator address.
    /// @param publicKey The public key to convert.
    /// @return operator address The operator address.
    function operatorAddressFromPublicKey(bytes calldata publicKey) internal pure returns (address operator) {
        // Implementation might depend on the exact key type used (e.g., sr25519)
        // This is a common simplification for EVM addresses derived from keys.
        // Ensure this matches the derivation used in your Tangle setup.
        return address(uint160(uint256(keccak256(publicKey)))); // Keccak hash, take lower 160 bits
    }
} 